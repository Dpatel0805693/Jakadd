# plumber_ols.R - OLS Regression Service
# Port: 8000
# FIXED: Accepts inline data parameter
library(plumber)
library(broom)
library(jsonlite)

#* @apiTitle OLS Regression Service
#* @apiDescription Performs Ordinary Least Squares regression analysis

# ---------------- CORS Filter ----------------
#* @filter cors
function(req, res) {
  res$setHeader("Access-Control-Allow-Origin", "*")
  res$setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
  res$setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization")
  
  if (req$REQUEST_METHOD == "OPTIONS") {
    res$status <- 200
    return(list())
  }
  
  plumber::forward()
}

# ---------------- Helper to parse body ----------------
parse_body <- function(req) {
  body <- tryCatch(
    jsonlite::fromJSON(req$postBody, simplifyVector = FALSE),
    error = function(e) NULL
  )
  return(body)
}

# ---------------- Endpoints ----------------

#* Health check
#* @get /ping
function() {
  list(
    status = "healthy",
    service = "ols",
    port = 8000,
    timestamp = format(Sys.time(), "%Y-%m-%d %H:%M:%S")
  )
}

#* Perform OLS regression
#* @post /ols
function(req, res) {
  tryCatch({
    # Parse JSON body
    body <- parse_body(req)
    
    if (is.null(body)) {
      res$status <- 400
      return(list(error = "Invalid JSON body"))
    }
    
    # Get parameters
    inline_data <- body$data
    data_path <- body$data_path
    dependent_var <- body$dependent_var
    independent_vars <- body$independent_vars
    formula_str <- body$formula
    
    # Load data - prefer inline data over file path
    data <- NULL
    
    if (!is.null(inline_data) && length(inline_data) > 0) {
      # Convert inline JSON data to data frame
      data <- tryCatch({
        df <- do.call(rbind, lapply(inline_data, function(row) {
          as.data.frame(row, stringsAsFactors = FALSE)
        }))
        # Ensure numeric columns are numeric
        for (col in names(df)) {
          if (is.character(df[[col]])) {
            numeric_vals <- suppressWarnings(as.numeric(df[[col]]))
            if (!all(is.na(numeric_vals))) {
              df[[col]] <- numeric_vals
            }
          }
        }
        df
      }, error = function(e) {
        message("Error parsing inline data: ", e$message)
        NULL
      })
    } else if (!is.null(data_path)) {
      # Try to load from file
      data <- tryCatch({
        if (grepl("\\.csv$", data_path, ignore.case = TRUE)) {
          read.csv(data_path, stringsAsFactors = FALSE)
        } else if (grepl("\\.xlsx?$", data_path, ignore.case = TRUE)) {
          if (requireNamespace("readxl", quietly = TRUE)) {
            readxl::read_excel(data_path)
          } else {
            stop("readxl package not available")
          }
        } else {
          stop("Unsupported file format")
        }
      }, error = function(e) {
        message("Error loading file: ", e$message)
        NULL
      })
    }
    
    if (is.null(data) || nrow(data) == 0) {
      res$status <- 400
      return(list(error = "No data provided or data could not be loaded"))
    }
    
    # Build formula
    if (!is.null(formula_str)) {
      # Use provided formula string
      model_formula <- as.formula(formula_str)
    } else if (!is.null(dependent_var) && !is.null(independent_vars)) {
      # Build formula from dependent/independent vars
      if (is.list(independent_vars)) {
        independent_vars <- unlist(independent_vars)
      }
      formula_str <- paste(dependent_var, "~", paste(independent_vars, collapse = " + "))
      model_formula <- as.formula(formula_str)
    } else {
      res$status <- 400
      return(list(error = "Provide either 'formula' or 'dependent_var' + 'independent_vars'"))
    }
    
    # Verify columns exist
    formula_vars <- all.vars(model_formula)
    missing_vars <- setdiff(formula_vars, names(data))
    if (length(missing_vars) > 0) {
      res$status <- 400
      return(list(
        error = "Variables not found in data",
        missing = missing_vars,
        available = names(data)
      ))
    }
    
    # Fit OLS model
    model <- lm(model_formula, data = data)
    
    # Extract tidy results using broom
    tidy_results <- tidy(model, conf.int = TRUE)
    glance_results <- glance(model)
    
    # Add diagnostics
    diagnostics <- list(
      residuals = as.numeric(residuals(model)),
      fitted = as.numeric(fitted(model)),
      standardized_residuals = as.numeric(rstandard(model))
    )
    
    # Generate R code for reproducibility
    r_code <- paste0(
      "# OLS Regression Analysis\n",
      "# Generated by StatsMate\n\n",
      "library(broom)\n\n",
      "# Load your data\n",
      "data <- read.csv('your_data.csv')\n\n",
      "# Fit model\n",
      "model <- lm(", formula_str, ", data = data)\n\n",
      "# View results\n",
      "summary(model)\n",
      "tidy(model, conf.int = TRUE)\n",
      "glance(model)\n",
      "confint(model)\n"
    )
    
    # Return results
    list(
      status = "success",
      model_type = "ols",
      formula = formula_str,
      n_obs = nrow(data),
      tidy = tidy_results,
      glance = glance_results,
      diagnostics = diagnostics,
      r_code = r_code,
      timestamp = format(Sys.time(), "%Y-%m-%d %H:%M:%S")
    )
    
  }, error = function(e) {
    res$status <- 500
    list(
      error = "Analysis failed",
      message = as.character(e$message)
    )
  })
}

#* Health check endpoint
#* @get /health
function() {
  list(
    status = "healthy",
    service = "r-ols",
    port = 8000,
    timestamp = format(Sys.time(), "%Y-%m-%d %H:%M:%S")
  )
}